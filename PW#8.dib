#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"aliases":[],"languageName":"csharp","name":"csharp"}]}}

#!markdown

# Практическая работа №8. Реализация планировщика команд.

**Цель:** Реализация длительных операций.

**Результаты:** После выполнения работы Вы сможете:
1. Сделать возможным в потоке выполнять длительные операции.

## Задание.
Пусть, в условиях практической работы №7, у нас есть поток с очередью, который в цикле извлекает команды из очереди и выполняет их.

Некоторые из команд не могут выполнить всю работу за один вызов метода Execute без блокирования на длительное время выполнения всех остальных командд из очереди.

Например, если какая-нибудь сетевая игра представлена командой, то пока одна игра не закончится, следующая не начнется. Чтобы эффективнее использовать процессорные
можности, нужно обеспечить возхможность поиграть как можно большему количеству игроков.

Для этого используют режим псевдопараллельной обработки. Когда все время работы разбивают на небольшие отрезки, каждый из которых выполняется
за один вызов метода Execute. Чтобы выполнить всю работу, нужно вызвать метод Execute несколько раз, до тех пор пока работа не будет завершена.
Это позволяет между вызовами Execute одного экземплыра команды вызывать метод Execute других команд.

Так устроен, например, ренедринг страницы в браузере. Только в браузеоре это используется не для рендеренга всех вкладок, а для обработки 
реакций пользователя на странице.

В прошлой работе все команды, которые выполнялись в потоке, брались из очереди. Поэтому первая идея - это положить долгоиграющую операцию обратно в очередь.
Но это может привести к состоянию мертвой блокировки потока: если очередь будет полна, то поток, который попытается сделать запись, будет заблокирован до тех пор, 
пока в очереди не появится свободное место. Поэтому нельзя в одном и том же потоке читать и писать в очередь неблокируемым образом.

Чтобы избежать мертвой блокировки потока, необходимо ввести понятие Планировщика, который будет отвечать за выбор следующей длительной задачи для выполнения,
а чтение из очереди оставить только для новых операций. 

#!csharp

using System;
using System.Collections.Generic;
using System.Collections.Concurrent;
using System.Threading;

#!csharp

public interface ICommand
{
    void Execute();
}

#!csharp

public interface ILongRunningCommand : ICommand
{
    int executions { get; }
    bool IsCompleted { get; }
}

#!csharp

public interface IScheduler
{
    bool HasCommand();
    ICommand Select();
    void Add(ICommand cmd);
}

#!csharp

public class Scheduler : IScheduler
{
    private ConcurrentQueue<ICommand> commandQueue = new ConcurrentQueue<ICommand>();
    private ConcurrentQueue<ILongRunningCommand> longRunningCommands = new ConcurrentQueue<ILongRunningCommand>();

    public bool HasCommand()
    {
        return commandQueue.Count > 0 || !longRunningCommands.IsEmpty;
    }

    public ICommand Select() // может быть и null!!!!
    {
        ICommand command;
        commandQueue.TryDequeue(out command);
        return command;
    }

    public void Add(ICommand cmd)
    {
        if (cmd is ILongRunningCommand longRunningCmd)
        {
            longRunningCommands.Enqueue(longRunningCmd);
        }
        else
        {
            commandQueue.Enqueue(cmd);
        }
    }

    public void ExecuteLongRunningCommands()
    {
        ILongRunningCommand lrc;
        if(longRunningCommands.TryDequeue(out lrc))
        {
            lrc.Execute();
            if(lrc.IsCompleted != true)
            {
                longRunningCommands.Enqueue(lrc);
            }
        }
    }
}

#!csharp

class HardWork : ILongRunningCommand 
{
    protected int Executions;
    public int executions 
    {
        get { return Executions; }
    }
    protected bool ISCompleted = false;
    public bool IsCompleted {
        get { return ISCompleted; } 
    }
    public HardWork(int executions)
    {
        Executions = executions;
    }
    public void Execute() 
    {
        Console.WriteLine($"Making WORK");
        if (Executions > 1)
        {
            Executions--;
        }
        else 
        {
            Executions = 0;
            ISCompleted = true;
        }
    }
}

#!csharp

class ServerThread : ICommand
{
    public bool mistake = false;
    public int name_of_thread = Thread.CurrentThread.GetHashCode();

    protected volatile bool hard_condition = false;
    public bool Hard_condition { get { return hard_condition; } }

    protected volatile bool soft_exception = false;
    public bool Soft_exception { get { return soft_exception; } }

    protected bool condition_to_carry_on = true;
    public bool Condition_to_carry_on { get { return condition_to_carry_on; } }

    protected Scheduler commands;
    public ServerThread()
    {
        commands = new Scheduler();
    }
    public void AddCommand(ICommand command) { commands.Add(command); }
    public void Execute()
    {
        name_of_thread = Thread.CurrentThread.GetHashCode();
        ICommand command;
        Console.WriteLine(Thread.CurrentThread.Name + " started its work");
        while (condition_to_carry_on)
        {
            try
            {
                if (commands.HasCommand())
                {
                    command = commands.Select();
                    if (command != null) command.Execute();
                    Process();
                    commands.ExecuteLongRunningCommands();
                }
                else
                {
                    if (soft_exception == true)
                    {
                        condition_to_carry_on = false;
                    }
                }

            }
            catch (Exception ex)
            {
                if (ex.Message.Contains("wrong thread")) 
                {
                    mistake = true;
                }
                Console.WriteLine (ex.Message);
                break;
            }
        }
    }
    public void Stop()
    {
        condition_to_carry_on = false;
    }
    protected void Process()
    {
        Console.WriteLine($"{Thread.CurrentThread.Name} processes");
        Thread.Sleep(1000);
    }
    public void HardStop()
    {
        hard_condition = true;
    }
    public void SoftStop()
    {
        soft_exception = true;
    }

}

#!csharp

class HardStop : ICommand
{
    protected Exception exception = new Exception("Hardstop execution is running in wrong thread!");
    ServerThread st;
    public HardStop(ServerThread st)
    {
        this.st = st;
    }

    public void Execute()
    {
        if (Thread.CurrentThread.GetHashCode() == st.name_of_thread)
        {
            st.HardStop();
            throw new Exception($"{Thread.CurrentThread.Name} has ended its work hardly!");
        }
        else
        {
            throw exception;
        }
    }
}

#!csharp

class SoftStop : ICommand
{
    protected Exception exception = new Exception("SoftStop execution is running in wrong thread!");
    ServerThread st;
    public SoftStop(ServerThread st)
    {
        this.st = st;
    }
    public void Execute()
    {
        if (Thread.CurrentThread.GetHashCode() == st.name_of_thread)
        {
            st.SoftStop();
        }
        else
        {
            throw exception;
        }
    }
}

#!csharp

class Checker
{
    public static void Checking(ServerThread program)
    {
        if (program.mistake == true) 
        {
            Console.WriteLine($"Server thread of {program.name_of_thread}has been ended by mistake");
        }
        else if (program.Soft_exception == true && program.Hard_condition != true)
        {
            Console.WriteLine($"Server thread of {program.name_of_thread}has been ended softly");
        }
        else if (program.Hard_condition == true)
        {
            Console.WriteLine($"Server thread of {program.name_of_thread}has been ended hardly");
        }
    }
}

#!csharp

ServerThread program = new ServerThread();
program.AddCommand(new SoftStop(program));
program.AddCommand(new SoftStop(program));
program.AddCommand(new SoftStop(program));
program.AddCommand(new HardWork(5));
program.AddCommand(new HardWork(5));
ServerThread program1 = new ServerThread();
program1.AddCommand(new SoftStop(program1));
program1.AddCommand(new SoftStop(program1));
program1.AddCommand(new SoftStop(program1));
program1.AddCommand(new HardStop(program));
program1.AddCommand(new HardWork(5));
program1.AddCommand(new HardWork(5));
Thread myThread = new Thread(new ThreadStart(program.Execute));
myThread.Name = "first thread";
myThread.Start();
Thread myThread1 = new Thread(new ThreadStart(program1.Execute));
myThread1.Name = "second thread";
myThread1.Start();
myThread.Join();
myThread1.Join();
Checker.Checking(program); // program отключается с помощью soft stop
Checker.Checking(program1); // program1 отключается из-за ошибки (hardstop запущен в другом потоке)

#!markdown

Необходимо реализовать поток, который способен реализоввывать длительные операции.

**Указание.** 
1. В практической работе №7 из очереди команды извлекались блокируеммым образом с помощью метода Take(), при наличии планировщика так делать нельзя: поток
может заснуть несмотря на наличие команд в планировщике до тех пор, пока не будет записана новая команда в очередь.

С другой стороны, если будем всегда читать неблокируемым образом, а в планировщике нет никакой работы, то будем тратить процессорное время без полезной нагрузки.

Необходимо учесть этот момент при реализации очереди.

2. Для обепечения справедливости стратегии планировщика в слабом смысле использовать стратегию Round Robbin (циклическую) для определения следующего потока на исполнение.
