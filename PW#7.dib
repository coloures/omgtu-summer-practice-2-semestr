#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"aliases":[],"languageName":"csharp","name":"csharp"}]}}

#!markdown

# Практическая работа №7.Реализация потока обработки команад.

**Цель:** Реализовать основу для многопоточного сервера приложений.

**Результаты:** После выполнения работы Вы сможете:
1. Обрабатывать множество операций в несколько потоков.
2. Останавливать потоки по запросу извне.

## Задание.
Пусть операция задана интерфейсом

#!csharp

public interface ICommand
{
    void Execute();
}

#!csharp

using System;
using System.Collections.Generic;
using System.Threading;
using System.Collections.Concurrent;
class ServerThread : ICommand
{
    protected bool mistake = false;
    public bool Mistake { get { return mistake; } }

    public int name_of_thread = Thread.CurrentThread.GetHashCode();

    protected volatile bool hard_condition = false;
    public bool Hard_condition { get { return hard_condition; }  }

    protected volatile bool soft_exception = false;
    public bool Soft_exception { get { return soft_exception;  } }

    protected bool condition_to_carry_on = true;
    public bool Condition_to_carry_on { get { return condition_to_carry_on; }  }

    protected ConcurrentQueue<ICommand> commands;
    public ServerThread()
    {
        commands = new ConcurrentQueue<ICommand>();
    }
    public void AddCommand(ICommand command) { commands.Enqueue(command); }
    public void Execute()
    {
        name_of_thread = Thread.CurrentThread.GetHashCode();
        ICommand command;
        Console.WriteLine(Thread.CurrentThread.Name + " started its work");
        while (condition_to_carry_on)
        {
            Console.WriteLine($"{commands.Count} - кол-во команд");
            try{
                if(commands.TryDequeue(out command))
                {
                    command.Execute();
                    Process();      
                }
                else
                {
                    if (soft_exception == true)
                    {
                        condition_to_carry_on = false;
                    }
                }
            }
            catch (Exception ex)
            {
                if (ex.Message.Contains("wrong thread")) 
                {
                    mistake = true;
                }
                break;
            }
        }
    }
    public void Stop()
    {
        condition_to_carry_on = false;
    }
    protected void Process()
    {
        Console.WriteLine($"{Thread.CurrentThread.Name} processes");
        Thread.Sleep(1000);
    }
    public void HardStop()
    {
        hard_condition = true;
    }
    public void SoftStop()
    {
        soft_exception = true;
    }

}

#!csharp

class SoftStop: ICommand 
{
    protected Exception exception = new Exception("SoftStop execution is running in wrong thread!");
    ServerThread st;
    public SoftStop(ServerThread st)
    {
        this.st = st;
    }
    public void Execute() 
    {
        if (Thread.CurrentThread.GetHashCode() == st.name_of_thread)
        {
            st.SoftStop();
        }
        else
        {
            throw exception;
        }
    }
}

#!csharp

class HardStop : ICommand 
{
    protected Exception exception = new Exception("Hardstop execution is running in wrong thread!");
    ServerThread st;
    public HardStop(ServerThread st) 
    {
        this.st = st;
    }

    public void Execute() 
    {
        if (Thread.CurrentThread.GetHashCode() == st.name_of_thread)
        {
            st.HardStop();
            throw new Exception ($"{Thread.CurrentThread.Name} has ended its work hardly!");
        }
        else 
        {
            throw exception;
        }
    }
}

#!csharp

class Checker 
{
    public static void Checking(ServerThread program) 
    {
        if(program.Mistake == true)
        {
            Console.WriteLine($"Server thread of {program.name_of_thread}has been ended by your mistake");
        }
        else if (program.Soft_exception == true && program.Hard_condition != true)
        {
            Console.WriteLine($"Server thread of {program.name_of_thread }has been ended softly");
        }
        else if (program.Hard_condition == true)
        {
            Console.WriteLine($"Server thread of {program.name_of_thread}has been ended hardly");
        }
    }
}

#!csharp

ServerThread program = new ServerThread();
ServerThread program1 = new ServerThread();

program.AddCommand(new HardStop(program));
program.AddCommand(new SoftStop(program));
program.AddCommand(new SoftStop(program));

program1.AddCommand(new SoftStop(program1));
program1.AddCommand(new SoftStop(program1));
Thread myThread = new Thread(new ThreadStart(program.Execute));
myThread.Name = "first thread";
myThread.Start();
Thread myThread1 = new Thread(new ThreadStart(program1.Execute));
myThread1.Name = "second thread";
myThread1.Start();
myThread.Join();
myThread1.Join();
Checker.Checking(program); // program отключается с помощью hard stop
Checker.Checking(program1); // program1 отключается с помощью soft stop

#!markdown

Классы, наследующие интерйес ICommand будем называть **Командами.**

Реализовать класс ServerThread и команды по hard и soft завершению потока. 

ServerThread может менять свое поведение для обработки следующей Команды.
Исключение, выброшенное из Команды, перехватывается и передается вместе с самой Командой в ExceptionHandler (см. ЛР №5) Примечание. Наличие реализованного обработчика исключений не обязательно для выполнения данной задачи. 

Команда HardStop приводит к немедленной остановке потока, несмотря на, что в очереди потока есть еще Команды.
Команда  SoftStop останавливает поток, когда в очереди потока закончатся все Команды.

Команды HardStop и SoftStop успешно выполняются только в потоке, который они должны остановить, в противном случае выбрасывают исключение.
Отсутствие Команд в очереди потока не должно требовать значительных затрат процессорного времени. Значительными считаются затраты, которые зависят от времени простоя потока.

Написать проверку, которая гарантирует правильное выполнение команд HardStop и SoftStop.
