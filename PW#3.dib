#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"aliases":[],"languageName":"csharp","name":"csharp"}]}}

#!markdown

# Практическая работа №1. Знакомство с потоками.

**Цель:** Познакомиться с возможностями класса System.Thread платформы .NET Framework.

**Результаты:** После выполнения работы Вы сможете:
1. Запускать длительные операции в отдельном потоке.
2. Завершать поток.
3. Дожидаться завершения выполнения потока. 


**Материалы для самостоятельного изучения**.
1. [Основы управления потоками](https://learn.microsoft.com/en-us/dotnet/standard/threading/managed-threading-basics)
2. [Использование потоков](https://learn.microsoft.com/en-us/dotnet/standard/threading/using-threads-and-threading)
3. [Примитив синхронизации Барьер](https://learn.microsoft.com/ru-ru/dotnet/standard/threading/barrier)
4. [Interlocked операции](https://learn.microsoft.com/en-us/dotnet/api/system.threading.interlocked?view=net-8.0)

## Задание.
Реализовать вычисление определенного интеграла методом трапеции в несколько потоков.

Отрезок, на котором происходит вычисление, разбивается на отрезки по количеству потоков. Для каждого отрезка значение 
интеграла считается в отдельном потоке, после завершения вычисоения полученный рельтаты суммирутся.

**Указание**.
1. Для суммирования результатов удобно воспользоваться разделяемой переменной, к которой будут прибалятся результаты вычисления прямо в самом потоке. Для синхронизации операций сложения лучше всего восользоваться [Interlocked операцией](https://learn.microsoft.com/en-us/dotnet/api/system.threading.interlocked?view=net-8.0).
2. Основная функция долна дождаться завершения всех потоков, которые вычисляют значение на отрезках, прежде чем возвратить результат. Для этого удобнее всего использовать Примитив синхронизации Барьер](https://learn.microsoft.com/ru-ru/dotnet/standard/threading/barrier).

#!csharp

using System.Threading;
using System.Diagnostics;
//
// Вычисление определенного интеграла
//
class Part
{
    public double start;
    public double end;
    public Func<double, double> function;
    public double step;
    public double res;   
}
class DefiniteIntegral
{
    //
    // a, b - границы отрезка, на котором происходит вычисление опредленного интеграла
    // function - функция, для которой вычисляется определнный интеграл
    // step - размер одного шага разбиения
    // threadsNumber - число потоков, которые используются для вычислений
    //
    static int Counter = 0;
    public static void ProcessItself(object obj) 
    {
        Part p_obj = obj as Part;
        int divisions = (int)((p_obj.end - p_obj.start) / p_obj.step);
        for (int i = 0; i < divisions; i++)
        {
            double sum = p_obj.res + 
                (p_obj.function(p_obj.start + p_obj.step * i) + p_obj.function(p_obj.start + p_obj.step * (i + 1))) / 2 * p_obj.step;
            Interlocked.Exchange(ref p_obj.res, sum);
        }
        Interlocked.Increment(ref Counter);
    }
    public static double Solve(double a, double b, Func<double, double> function, double step, int threadsnumber)
    {
        Counter = 0;
        Part[] parts = new Part[threadsnumber];
        Thread myThread;
        for (int i = 1; i <= threadsnumber; i++)
        {
            parts[i - 1] = new Part() { start = a + (b - a) / threadsnumber * (i - 1),
                end = a + (b - a) / threadsnumber * i, function = function, step = step, res = 0.0};
            myThread = new Thread(new ParameterizedThreadStart(ProcessItself));

            myThread.Start(parts[i - 1]);
        }
        double result = 0.0;
        while (Counter != threadsnumber) { }
        foreach (Part part in parts) { result += part.res; }
        // отсюда надо начинать реализацию задачи
        return result;
    }
}

#!csharp

#r "nuget: xunit, 2.8.1"

// Setup a custom formatter to display plots as images
using Xunit;

var SIN = (double x) => Math.Sin(x);

long [] Optimal_Time = new long [12]; // Ox
int [] Threads = Enumerable.Range(1,12).Select(x => x*1).ToArray<int>(); // Oy

double step = 1e-4;

Stopwatch stopWatch = new Stopwatch(); // создание таймера

for(int i = 0; i < 5; i++)
{
    Console.WriteLine(i);
    for(int threads = 1; threads <= 12; threads++)
    {
        try
        {
            stopWatch.Reset();
            stopWatch.Start();
            Assert.Equal(0, DefiniteIntegral.Solve(-100, 100, SIN, step , threads), 1e-4);
            stopWatch.Stop();
            Optimal_Time[threads-1] = i == 0 ? stopWatch.Elapsed.Ticks : (Optimal_Time[threads-1]+stopWatch.Elapsed.Ticks)/2; // вычисление среднего значения для каждого из потоков
        }
        catch(Xunit.Sdk.EqualException){Console.WriteLine($"Calculation error from {threads} number of threads"); break;}
        

    }
}

#!csharp

//#r "nuget:ScottPlot, 5.0.*"
// Setup a custom formatter to display plots as images
using Microsoft.DotNet.Interactive.Formatting;
Formatter.Register(typeof(ScottPlot.Plot), (p, w) => 
    w.Write(((ScottPlot.Plot)p).GetImageHtml(400, 300)), HtmlFormatter.MimeType);

//Console.WriteLine(Optimal_Time[11]); данная строка присутствует для вывода точного кол-ва тиков для любого из кол-ва потоков

ScottPlot.Plot plt = new(); // создание нового графика
plt.Add.Scatter(Optimal_Time, Threads); 
plt

#!markdown

Summary

Минимальный размер шага 1е-4 (для 1е-1, 1е-2 и 1е-3 срабатывает блок catch).

Для точности 1е-4: Многопоточная система: 7 потоков и 232163 тика; Однопоточная система: 339869 тиков => около 47% прирост времени для однопоточной.

Для точности 1e-5: Многопоточная система: 7 потоков и 2107660 тиков; Однопоточная система: 3006981 тиков => около 43% прирост времени для однопоточной.

Для точности 1е-6: Многопоточная система: 12 потоков и 18790346 тиков; Однопоточная система: 30243855 тиков => около 61% прирост времени для однопоточной.

** В качестве однопоточной системы использовал метод класса TrapezoidalRule, который был написан во 2-ом семесте в одном из заданий по предмету "Практикум по программированию".
